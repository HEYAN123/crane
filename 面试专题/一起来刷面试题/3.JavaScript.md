# JavaScript

## 1. get请求传参长度的误区

误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的
实际上HTTP协议从未规定GET、POST请求长度限制是多少。对get请求参数的限制是来源于浏览器或web服务器，浏览器或web服务器限制了url长度。
不同的浏览器和web服务器限制的最大长度也不一样。要支持IE，则最大长度为2083byte，若只支持chrome，则最大长度为8182byte

## 2. 补充get和post在缓存方面的区别

get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存

post做的一般是修改和删除的操作，所以必须与数据库交互，所以不能使用缓存，因此get请求适合做缓存

## 3. 说一下闭包

闭包就是能够访问其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放

## 4. 说一下类的创建和继承

### 类的创建

声明一个function，在这个function的prototype里增加属性和方法

```javascript
function Animal(name) {
    this.name = name || 'Animal';
    this.sleep = function() {
        console.log(name+'is sleeping');
    }
}

Animal.prototype.eat = function(food) {
    console.log(this.name+' is eating the '+food);
}

```

### 类的继承

[]

1. 原型链继承

```javascript
function Cat() {
    Cat.prototype = new Animal();
    Cat.prototype.name = 'cat';
}

var cat = new Cat();
```

特点：基于原型链的继承，即是父类的实例，也是子类的实例
缺点：原型只能指定一个，无法实现多继承

2. 构造继承

使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类

```javascript
function Cat(name) {
    Animal.call(this);
    this.name = name || 'Tom';
}
var cat = new Cat(); //这里就继承不到eat原型方法
```

特点：可以实现多继承
缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法

3. 组合继承

4. 寄生组合继承

## 5. 如何解决异步回调地狱

- promise
- generator
- async/await

## 6. 说一说前端的事件流

HTML中与js交互是通过事件驱动来实现的，可以向文档或者文档中的元素添加事件侦听器来预定事件。要想知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念

什么是事件流：事件流描述的是从页面接收事件的顺序，DOM2级事件流包括下面几个阶段：

- 事件捕获阶段
- 处于目标阶段
- 事件冒泡阶段

addEventListener：是DOM2级事件新增的指定事件处理程序的操作，这个方法接收3个参数，要处理的事件名，作为事件处理程序的函数和一个布尔值。最后这个布尔值为true时表示在捕获阶段调用处理程序，false表示在冒泡阶段执行事件处理程序

IE只支持事件冒泡

## 7. 如何让事件先冒泡后捕获

分别为某一元素先后绑定两个监听器，第一个监听器第三个参数设为false，第二个监听器第三个参数设为true

## 8. 说一下事件委托

事件委托是指，不在事件的发生地（目标）上设置监听函数，而是在其父元素上设置监听函数。通过事件冒泡父元素可以监听到子元素上事件的触发，通过判断事件发生元素的类型来做出不同的响应

好处：比较适合动态元素的绑定，新添加的子元素也有监听函数，也可以有事件触发机制

## 9. 说一下图片的懒加载和预加载

预加载：提前加载图片。当用户需要查看时可直接从本地缓存中渲染，加快响应速度

懒加载：懒加载的主要目的是：作为服务器前端的优化，减少请求数或延迟请求数

## mouseover和mouseenter的区别

