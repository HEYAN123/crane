<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [JavaScript](#javascript)
  - [1. get请求传参长度的误区](#1-get%e8%af%b7%e6%b1%82%e4%bc%a0%e5%8f%82%e9%95%bf%e5%ba%a6%e7%9a%84%e8%af%af%e5%8c%ba)
  - [2. 补充get和post在缓存方面的区别](#2-%e8%a1%a5%e5%85%85get%e5%92%8cpost%e5%9c%a8%e7%bc%93%e5%ad%98%e6%96%b9%e9%9d%a2%e7%9a%84%e5%8c%ba%e5%88%ab)
  - [3. 说一下闭包](#3-%e8%af%b4%e4%b8%80%e4%b8%8b%e9%97%ad%e5%8c%85)
  - [4. 说一下类的创建和继承](#4-%e8%af%b4%e4%b8%80%e4%b8%8b%e7%b1%bb%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e7%bb%a7%e6%89%bf)
    - [类的创建](#%e7%b1%bb%e7%9a%84%e5%88%9b%e5%bb%ba)
    - [类的继承](#%e7%b1%bb%e7%9a%84%e7%bb%a7%e6%89%bf)
  - [5. 如何解决异步回调地狱](#5-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e5%bc%82%e6%ad%a5%e5%9b%9e%e8%b0%83%e5%9c%b0%e7%8b%b1)
  - [6. 说一说前端的事件流](#6-%e8%af%b4%e4%b8%80%e8%af%b4%e5%89%8d%e7%ab%af%e7%9a%84%e4%ba%8b%e4%bb%b6%e6%b5%81)
  - [7. 如何让事件先冒泡后捕获](#7-%e5%a6%82%e4%bd%95%e8%ae%a9%e4%ba%8b%e4%bb%b6%e5%85%88%e5%86%92%e6%b3%a1%e5%90%8e%e6%8d%95%e8%8e%b7)
  - [8. 说一下事件委托](#8-%e8%af%b4%e4%b8%80%e4%b8%8b%e4%ba%8b%e4%bb%b6%e5%a7%94%e6%89%98)
  - [9. 说一下图片的懒加载和预加载](#9-%e8%af%b4%e4%b8%80%e4%b8%8b%e5%9b%be%e7%89%87%e7%9a%84%e6%87%92%e5%8a%a0%e8%bd%bd%e5%92%8c%e9%a2%84%e5%8a%a0%e8%bd%bd)
  - [10. mouseover和mouseenter的区别](#10-mouseover%e5%92%8cmouseenter%e7%9a%84%e5%8c%ba%e5%88%ab)
  - [11. js的new操作符做了哪些操作](#11-js%e7%9a%84new%e6%93%8d%e4%bd%9c%e7%ac%a6%e5%81%9a%e4%ba%86%e5%93%aa%e4%ba%9b%e6%93%8d%e4%bd%9c)
  - [12. 改变函数内部this指向的函数](#12-%e6%94%b9%e5%8f%98%e5%87%bd%e6%95%b0%e5%86%85%e9%83%a8this%e6%8c%87%e5%90%91%e7%9a%84%e5%87%bd%e6%95%b0)
  - [13. js中clientHeight，scrollHeight，offsetHeight等的区别](#13-js%e4%b8%adclientheightscrollheightoffsetheight%e7%ad%89%e7%9a%84%e5%8c%ba%e5%88%ab)
  - [14. jst拖拽功能的实现](#14-jst%e6%8b%96%e6%8b%bd%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%9e%e7%8e%b0)
    - [1. 事件监听](#1-%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac)
    - [2. html5Drag](#2-html5drag)
  - [15. 异步加载js的方法](#15-%e5%bc%82%e6%ad%a5%e5%8a%a0%e8%bd%bdjs%e7%9a%84%e6%96%b9%e6%b3%95)
    - [1. defer](#1-defer)
    - [2. async](#2-async)
    - [3. 动态创建script标签](#3-%e5%8a%a8%e6%80%81%e5%88%9b%e5%bb%bascript%e6%a0%87%e7%ad%be)
  - [16. ajax阻止缓存请求](#16-ajax%e9%98%bb%e6%ad%a2%e7%bc%93%e5%ad%98%e8%af%b7%e6%b1%82)
  - [17. js中的防抖和节流](#17-js%e4%b8%ad%e7%9a%84%e9%98%b2%e6%8a%96%e5%92%8c%e8%8a%82%e6%b5%81)
    - [节流叫throttle](#%e8%8a%82%e6%b5%81%e5%8f%abthrottle)
    - [防抖叫debounce](#%e9%98%b2%e6%8a%96%e5%8f%abdebounce)
  - [18. js中的垃圾回收机制](#18-js%e4%b8%ad%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# JavaScript

## 1. get请求传参长度的误区

误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的
实际上HTTP协议从未规定GET、POST请求长度限制是多少。对get请求参数的限制是来源于浏览器或web服务器，浏览器或web服务器限制了url长度。
不同的浏览器和web服务器限制的最大长度也不一样。要支持IE，则最大长度为2083byte，若只支持chrome，则最大长度为8182byte

## 2. 补充get和post在缓存方面的区别

get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存

post做的一般是修改和删除的操作，所以必须与数据库交互，所以不能使用缓存，因此get请求适合做缓存

## 3. 说一下闭包

闭包就是能够访问其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放

## 4. 说一下类的创建和继承

### 类的创建

声明一个function，在这个function的prototype里增加属性和方法

```javascript
function Animal(name) {
    this.name = name || 'Animal';
    this.sleep = function() {
        console.log(name+'is sleeping');
    }
}

Animal.prototype.eat = function(food) {
    console.log(this.name+' is eating the '+food);
}

```

### 类的继承

[]

1. 原型链继承

```javascript
function Cat() {
    Cat.prototype = new Animal();
    Cat.prototype.name = 'cat';
}

var cat = new Cat();
```

特点：基于原型链的继承，即是父类的实例，也是子类的实例
缺点：原型只能指定一个，无法实现多继承

2. 构造继承

使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类

```javascript
function Cat(name) {
    Animal.call(this);
    this.name = name || 'Tom';
}
var cat = new Cat(); //这里就继承不到eat原型方法
```

特点：可以实现多继承
缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法

3. 组合继承

4. 寄生组合继承

## 5. 如何解决异步回调地狱

- promise
- generator
- async/await

## 6. 说一说前端的事件流

HTML中与js交互是通过事件驱动来实现的，可以向文档或者文档中的元素添加事件侦听器来预定事件。要想知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念

什么是事件流：事件流描述的是从页面接收事件的顺序，DOM2级事件流包括下面几个阶段：

- 事件捕获阶段
- 处于目标阶段
- 事件冒泡阶段

addEventListener：是DOM2级事件新增的指定事件处理程序的操作，这个方法接收3个参数，要处理的事件名，作为事件处理程序的函数和一个布尔值。最后这个布尔值为true时表示在捕获阶段调用处理程序，false表示在冒泡阶段执行事件处理程序

IE只支持事件冒泡

## 7. 如何让事件先冒泡后捕获

分别为某一元素先后绑定两个监听器，第一个监听器第三个参数设为false，第二个监听器第三个参数设为true

## 8. 说一下事件委托

事件委托是指，不在事件的发生地（目标）上设置监听函数，而是在其父元素上设置监听函数。通过事件冒泡父元素可以监听到子元素上事件的触发，通过判断事件发生元素的类型来做出不同的响应

好处：比较适合动态元素的绑定，新添加的子元素也有监听函数，也可以有事件触发机制

## 9. 说一下图片的懒加载和预加载

预加载：提前加载图片。当用户需要查看时可直接从本地缓存中渲染，加快响应速度

懒加载：懒加载的主要目的是：作为服务器前端的优化，减少请求数或延迟请求数

## 10. mouseover和mouseenter的区别

都表示鼠标移入的事件

而mouseover意味着移入元素及其子元素都会触发事件（会冒泡），对应移出事件为mouseout
mouseenter只有移入元素本身时才会触发，子元素不会（不会冒泡），对应移出事件为mouseleave

## 11. js的new操作符做了哪些操作

new动作四部曲：

1 创建一个新对象

2 原型链接（该对象原型指向构造函数的prototype）

3 this指向这个新对象并调用

4 返回调用结果或者新对象

## 12. 改变函数内部this指向的函数

apply：第一个参数是this指向的目标，第二个参数是要传入的参数数组，调用时候会直接执行函数

call：第一个参数是this指向的目标，第二个及之后的参数是要传入的数个参数，调用时候会直接执行函数

bind：第一个参数是this指向的目标，后续的是要传入的参数，返回一个新的函数，而不会直接执行

## 13. js中clientHeight，scrollHeight，offsetHeight等的区别

[]

clientHeight：表示的是可视区域的高度，不包括border和滚动条
offsetHeight：表示的是可视区域的高度，包括了border和滚动条
scrollHeight：表示了所有区域的高度。包含了因为滚动被隐藏的部分
clientTop：表示边框border的厚度，在未指定的情况下为0
scrollTop：滚动后被隐藏的高度

## 14. jst拖拽功能的实现

### 1. 事件监听

[]

### 2. html5Drag

[]

## 15. 异步加载js的方法

### 1. defer

defer属性规定是否对脚本执行进行延迟，直到页面加载完为止

只有IE浏览器支持该属性

### 2. async

async规定脚本一旦可用，则会异步执行（页面继续进行解析，脚本也将被执行）
优先级低于defer

### 3. 动态创建script标签

在合适的时机用JavaScript创建脚本标签并插入文档里

## 16. ajax阻止缓存请求

1. 在ajax发送请求前加上ajaxObj.setRequestHeader("If-Modified-Since", "0")
2. 在ajax发送请求前加上ajaxObj.setRequestHeader("Cache-Control", "no-cache")
3. 在url后面加一个随机数："fresh="+Math.rendom()
4. 在url后面加上时间戳："nowtime="+new Date().getTime()

## 17. js中的防抖和节流

### 节流叫throttle

表示单位时间内只能执行一次函数，若多次触发，那就只执行1次函数

```javascript
var throttle = function (action, time) {
    var date = 0;
    return (...args) => {
        var now = Date.now();
        if(now-date>time) {
            action.apply(this,args);
            date = now;
        }
    }
}
```

### 防抖叫debounce

表示事件触发指定时间段后再执行函数，若这个时间段内重复触发，那就重新计时

```javascript
var debounce = function (action, delay) {
    var last;
    return (...args) => {
        var ctx = this;
        clearTimeout(last);
        last = setTimeout(()=>{
            action.apply(ctx, args);
        }, delay);
    }
}
```

## 18. js中的垃圾回收机制

必要性：