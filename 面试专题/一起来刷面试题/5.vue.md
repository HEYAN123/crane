# vue

## 1. 说说你对spa单页面应用的理解，它的优缺点分别是什么

spa仅在web页面初始化时加载相应的html，js，css，一旦页面加载完成，spa不会因为用户的操作而进行页面的重新加载或跳转，取而代之的是利用路由机制实现html内容的变换，ui与用户的交互，避免页面的重新加载

优点：

- 用户的体验好，快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。
- 基于上面一点，spa相对于服务器的压力小
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理

缺点：

- 初次加载耗时多，为实现单页面web应用功能及显示效果，需要在加载页面的时候将js，css统一加载，部分页面按需加载
- 前进后退由路由管理，由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有页面的切换需要自己建立堆栈管理
- SEO难度大，由于所有的内容都是在一个页面中动态替换显示，所以在seo中有着天然弱势

## 2. v-show和v-if有什么区别

v-if是真正的条件渲染，因为他会确保在切换过程中条件块内的事件监听和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染条件为假时，则什么也不做——直到条件第一次变为真时才开始渲染条件块

v-show就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于css的display进行切换

所以，v-if适用于切换不频繁的场景，v-show适用于切换频繁的场景

## 3. class和style如何动态绑定

class可以通过对象语法和数组语法进行动态绑定：

- 对象语法：

```js
<div v-bind:class="{active: isActive, 'text-danger': hasError }"></div>
data: {
    isActive: true,
    hasError: false
}
```

- 数组语法：

```js
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
data: {
    activeClass: 'active',
    errorClass: 'text-danger'
}
```

style也可以通过对象语法和数组语法进行动态绑定

## 4. 怎样理解vue里的单向数据流

所有的prop都使得其父子prop之间形成一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来不行，这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流难以解释

额外地，每次父级组件发生更新时，子组件中的所有prop都会刷新为最新的值，这意味着你不应该在一个子组件内部改变prop，如果你这样做了，vue会在浏览器的控制台发出警告，子组件想修改时，只能通过$emit派发一个自定义事件，父组件接收到后，由父组件修改。

## 5. computed和watch的区别和运用场景

computed：是计算属性，依赖其他属性值，并且computed的值有缓存，只有他依赖的属性值发生改变时下一次获取computed的值时候才会重新计算computed的值

watch：更多的是观察作用，类似于某些数据的监听回调，每当监听的数据发生变化时都会执行回调进行后续操作

运用场景：

- 当我们需要进行数值计算，并依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时都要重新计算
- 但我们需要在数据变化时执行异步或开销较大的操作时应该使用watch，使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的。

## 6. 直接给一个数组项赋值，vue能检测到吗

由于js的限制，vue不能检测到以下数组的变动：

- 当你利用索引直接设置一个数组项时，例如vm.item[indexOfItem] = newValue
- 当你修改数组的长度时，例如vm.items.length = newLength

为了解决第一个问题，vue提供了以下操作方法：

```js
Vue.set(vm.items, indexOfItem, newValue)

Vue.$set(vm.items, indexOfItem, newValue)

Vue.items.splice(indexOfItem, 1, newValue)
```

为了解决第一个问题，vue提供了以下操作方法：

```js
vm.items.splice(newLength)
```

## 7. 谈谈你对vue生命周期的理解

- 生命周期是什么

vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载dom->渲染更新->渲染卸载等一些过程，我们称这是vue的生命周期

- 各个生命周期的作用

beforeCreate：组件被创建之初，组件的属性生效之前
created：组件实例已经完全创建，属性也绑定，但是真实的dom还没有生成，$el还不能用
beforeMount：在挂载开始之前被调用，相关的render函数首次被调用
mounted：el被新创建的vm.$el替换，并挂载到实例上去后调用该钩子
beforeUpdate：组件数据更新之前调用，发生在虚拟dom打补丁之前
updated：组件数据更新之后
activited：keep-alive专属，组件被激活时调用
deactivated：keep-alive专属，组件被销毁时调用
beforeDestroy：组件被销毁前
destroyed：组件被销毁后调用

## 8. vue父子组件生命周期钩子函数的执行顺序

- 加载渲染过程

父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted

- 子组件更新过程

父beforeUpdate->子beforeUpdate->子updated->父updated

- 父组件更新过程

父beforeUpdate->父updated

- 销毁过程

父beforeDestroy->子beforeDestroy->子destroyed->父destroy

## 9. 在哪个生命周期内调用异步请求

可以在函数created，beforeMount，mounted中进行调用，因为在这三个钩子函数中data已经可以创建，可以将服务端返回的数据进行赋值，但是比较推荐在created钩子函数中调用异步请求，因为：

- 能更快的获取到服务端数据，减少页面loading时间
- ssr不支持beforeMount，mounted钩子函数，所以放在created中有助于一致性

## 10. 在什么阶段才能访问操作DOM

在钩子函数mounted被调用之前，vue已经把编译好的模板挂载到页面上，所以在mounted中可以访问操作dom，vue具体的生命周期

## 11. 父组件可以监听到子组件的生命周期吗

- 手动设置$emit来发布监听

```js
// parent
<Child @mounted="fn" />
// child
mounted() {
    this.$emit("mounted");
}
```

- @hook

```js
// parent
<Child @hook:mounted="fn" />
fn() {
    console.log('get')
}
// child
mounted() {
    console.log('emit');
}
```

## 12. 谈谈你对keep-alive的了解

keep-alive是vue内置的一个组件，可以使被包含的组件保留状态，避免重复渲染，其有以下特性：

- 一般结合路由和动态组件使用，用于缓存组件
- 提供include和exclude属性，两者都支持字符串或正则表达式，include表示只有名字匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高
- 对应两个钩子函数actived和deactivated

## 13. 组件中的data为什么是个函数

因为组件是拿来复用的，且js里的对象是引用关系，如果组件中的data是一个对象，那么这样作用域没有隔离，子组件中的data属性值会相互影响，如果组件中的data是一个函数，那么每个势力可以维护一份被返回的
