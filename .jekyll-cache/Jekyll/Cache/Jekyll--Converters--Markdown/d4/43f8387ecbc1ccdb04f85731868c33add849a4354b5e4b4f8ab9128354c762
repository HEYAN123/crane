I"M7<ul id="markdown-toc">
  <li><a href="#基础类型" id="markdown-toc-基础类型">基础类型</a>    <ul>
      <li><a href="#ts中支持的基础数据类型" id="markdown-toc-ts中支持的基础数据类型">ts中支持的基础数据类型</a></li>
      <li><a href="#类型断言" id="markdown-toc-类型断言">类型断言</a></li>
    </ul>
  </li>
  <li><a href="#接口" id="markdown-toc-接口">接口</a>    <ul>
      <li><a href="#对象类型接口" id="markdown-toc-对象类型接口">对象类型接口</a></li>
      <li><a href="#函数类型接口" id="markdown-toc-函数类型接口">函数类型接口</a></li>
      <li><a href="#可索引类型接口" id="markdown-toc-可索引类型接口">可索引类型接口</a></li>
      <li><a href="#类类型接口" id="markdown-toc-类类型接口">类类型接口</a></li>
      <li><a href="#混合类型接口" id="markdown-toc-混合类型接口">混合类型接口</a></li>
      <li><a href="#接口继承接口" id="markdown-toc-接口继承接口">接口继承接口</a></li>
      <li><a href="#接口继承类" id="markdown-toc-接口继承类">接口继承类</a></li>
    </ul>
  </li>
  <li><a href="#函数" id="markdown-toc-函数">函数</a>    <ul>
      <li><a href="#函数类型" id="markdown-toc-函数类型">函数类型</a></li>
      <li><a href="#可选参数和默认参数" id="markdown-toc-可选参数和默认参数">可选参数和默认参数</a></li>
      <li><a href="#重载" id="markdown-toc-重载">重载</a></li>
    </ul>
  </li>
  <li><a href="#字面量类型" id="markdown-toc-字面量类型">字面量类型</a></li>
  <li><a href="#联合类型和交叉类型unions-and-intersection-types" id="markdown-toc-联合类型和交叉类型unions-and-intersection-types">联合类型和交叉类型（Unions and Intersection Types）</a></li>
  <li><a href="#类" id="markdown-toc-类">类</a>    <ul>
      <li><a href="#继承" id="markdown-toc-继承">继承</a></li>
      <li><a href="#类成员修饰符" id="markdown-toc-类成员修饰符">类成员修饰符</a></li>
      <li><a href="#参数属性" id="markdown-toc-参数属性">参数属性</a></li>
      <li><a href="#存取器" id="markdown-toc-存取器">存取器</a></li>
      <li><a href="#静态属性" id="markdown-toc-静态属性">静态属性</a></li>
      <li><a href="#抽象类" id="markdown-toc-抽象类">抽象类</a></li>
    </ul>
  </li>
  <li><a href="#泛型generics" id="markdown-toc-泛型generics">泛型（Generics）</a>    <ul>
      <li><a href="#泛型变量" id="markdown-toc-泛型变量">泛型变量</a></li>
      <li><a href="#泛型约束" id="markdown-toc-泛型约束">泛型约束</a></li>
    </ul>
  </li>
  <li><a href="#枚举" id="markdown-toc-枚举">枚举</a>    <ul>
      <li><a href="#数字枚举" id="markdown-toc-数字枚举">数字枚举</a></li>
      <li><a href="#字符串枚举" id="markdown-toc-字符串枚举">字符串枚举</a></li>
    </ul>
  </li>
  <li><a href="#变量声明" id="markdown-toc-变量声明">变量声明</a>    <ul>
      <li><a href="#varletconst" id="markdown-toc-varletconst">var,let,const</a></li>
      <li><a href="#解构" id="markdown-toc-解构">解构</a></li>
    </ul>
  </li>
  <li><a href="#类型推论" id="markdown-toc-类型推论">类型推论</a></li>
  <li><a href="#类型兼容性" id="markdown-toc-类型兼容性">类型兼容性</a></li>
  <li><a href="#高级类型" id="markdown-toc-高级类型">高级类型</a></li>
  <li><a href="#symbols" id="markdown-toc-symbols">Symbols</a></li>
  <li><a href="#迭代器和生成器" id="markdown-toc-迭代器和生成器">迭代器和生成器</a></li>
  <li><a href="#模块" id="markdown-toc-模块">模块</a></li>
  <li><a href="#命名空间" id="markdown-toc-命名空间">命名空间</a></li>
</ul>

<blockquote>
  <p>参考资料：
<a href="https://www.tslang.cn/docs/handbook/">https://www.tslang.cn/docs/handbook/</a>
<a href="https://www.typescriptlang.org/docs/handbook/">https://www.typescriptlang.org/docs/handbook/</a></p>
</blockquote>

<h2 id="基础类型">基础类型</h2>

<h3 id="ts中支持的基础数据类型">ts中支持的基础数据类型</h3>

<ul>
  <li>boolean：布尔值</li>
  <li>number：数字</li>
  <li>string：字符串</li>
  <li>[] / number[] / Array&lt;number&gt;：数组</li>
  <li>[string, number]：元组（表示一个已知元素数量和类型的数组，各元素类型不必相同）</li>
  <li>enum：枚举（为一组数值赋予友好的名字）</li>
  <li>any：不进行类型检查的任意类型</li>
  <li>void：没有任何类型（通常表示无返回值）</li>
  <li>null</li>
  <li>undefined</li>
  <li>never：永远不存在值的类型（总会抛出异常/无返回值的函数/箭头函数返回值/函数存在无法到达的终点）</li>
  <li>object</li>
</ul>

<h3 id="类型断言">类型断言</h3>

<ul>
  <li>表示人为确定某值应该当作什么类型去处理</li>
  <li>
    <p>有两种写法：</p>

    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">val</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">a string</span><span class="dl">"</span><span class="p">;</span>
<span class="c1">// 尖括号语法</span>
<span class="kd">let</span> <span class="nx">valLen1</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="nx">val</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
<span class="c1">// as 语法</span>
<span class="kd">let</span> <span class="nx">valLen2</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val</span> <span class="k">as</span> <span class="kr">string</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="接口">接口</h2>

<ul>
  <li>接口作用：
    <ol>
      <li>为类型命名</li>
      <li>为代码定义契约</li>
    </ol>
  </li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">LabelledValue</span> <span class="p">{</span>
  <span class="nl">label</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">printLabel</span><span class="p">(</span><span class="nx">labelObj</span><span class="p">:</span> <span class="nx">LabelledValue</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">labelObj</span><span class="p">.</span><span class="nx">label</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// it‘s ok</span>
<span class="nx">printLabel</span><span class="p">({</span>
  <span class="na">label</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span>
<span class="p">});</span>

<span class="c1">// error TS2345（对象字面量会经过额外属性检查，若存在目标类型不包含的属性时就会报错）</span>
<span class="nx">printLabel</span><span class="p">({</span>
  <span class="na">label</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">world</span><span class="dl">"</span>
<span class="p">});</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">label</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">world</span><span class="dl">"</span>
<span class="p">}</span>
<span class="c1">// 变量引用可绕过额外属性检查</span>
<span class="nx">printLabel</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>

<span class="c1">// 使用类型断言可以绕过额外属性检查</span>
<span class="nx">printLabel</span><span class="p">({</span> <span class="na">label</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">world</span><span class="dl">"</span> <span class="p">}</span> <span class="k">as</span> <span class="nx">LabelledValue</span><span class="p">);</span>


<span class="c1">// 使用字符串索引签名在接口中定义一个属性，表示该类型对象会带有任意数量的其他属性</span>
<span class="kr">interface</span> <span class="nx">Student</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="p">[</span><span class="nx">propName</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">any</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="对象类型接口">对象类型接口</h3>

<ul>
  <li>
    <p>可选属性：接口中定义可选的属性字段（对可能存在对属性进行预定义，引用不存在属性时将抛出错误）</p>

    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>只读属性：接口中定义只能在对象刚刚创建时修改其值的属性</p>

    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="k">readonly</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="函数类型接口">函数类型接口</h3>

<ul>
  <li>接口也可描述函数类型（包括参数类型和返回值类型）</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">QueryPerson</span> <span class="p">{</span>
  <span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">ifPersonExist</span><span class="p">:</span> <span class="nx">QueryPerson</span><span class="p">;</span>
<span class="c1">// 参数名可以不一样，参数和返回值类型可以不写 ts会依据接口进行类型推断</span>
<span class="nx">ifPersonExist</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="可索引类型接口">可索引类型接口</h3>

<ul>
  <li>可索引类型具有一个索引签名，它描述对象索引(key)的类型，还有相应的索引返回值(value)的类型</li>
  <li>ts支持两种索引类型：number，string</li>
  <li>同时使用两种索引类型时，二者的value类型需保持相同（因为都是转为string类型索引的）</li>
  <li>可以在接口中设置readonly，防止给索引赋值</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">StringArr</span> <span class="p">{</span>
  <span class="c1">// 表示key为number类型，value为string类型，并且不可修改</span>
  <span class="k">readonly</span> <span class="p">[</span><span class="nx">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">]:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">myArr</span><span class="p">:</span> <span class="nx">StringArr</span><span class="p">;</span>
<span class="nx">myArr</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">bob</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">fred</span><span class="dl">"</span><span class="p">];</span>

<span class="kd">let</span> <span class="nx">firstStr</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="nx">myArr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="类类型接口">类类型接口</h3>

<ul>
  <li>明确的强制一个类去符合某种契约</li>
  <li>接口描述了类的公共部分，而不是公共和私有两部分。它不会帮你检查类是否具有某些私有成员。</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">sayHi</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">Student</span> <span class="k">implements</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">sayHi</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span> <span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="混合类型接口">混合类型接口</h3>

<ul>
  <li>一个对象同时具备多种类型时需要的契约</li>
  <li>场景：接入js第三方库</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 假设一个对象同时可作为函数和对象使用，并带有额外的属性</span>
<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="c1">// 本身可当作函数执行</span>
  <span class="p">(</span><span class="nx">play</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="k">void</span><span class="p">;</span>
  <span class="c1">// 可获取的额外属性</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="c1">// 可获取的额外方法属性</span>
  <span class="nx">sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">:</span> <span class="kr">number</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">child</span><span class="p">():</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="kd">function</span> <span class="p">(</span><span class="nx">play</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">play</span><span class="dl">"</span><span class="p">,</span> <span class="nx">play</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Jim</span><span class="dl">"</span><span class="p">;</span>
  <span class="nx">person</span><span class="p">.</span><span class="nx">sleep</span> <span class="o">=</span> <span class="p">(</span><span class="nx">time</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">sleep</span><span class="dl">"</span><span class="p">,</span> <span class="nx">time</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">person</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">xiaoMin</span> <span class="o">=</span> <span class="nx">child</span><span class="p">();</span>

<span class="nx">xiaoMing</span><span class="p">(</span><span class="dl">"</span><span class="s2">foot ball</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">xiaoMing</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">xiaoMing</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">xiaoming</span><span class="p">.</span><span class="nx">sleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="接口继承接口">接口继承接口</h3>

<ul>
  <li>接口继承让我们可以灵活的分割接口，达到代码复用的目的。</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Action</span> <span class="p">{</span>
  <span class="nl">walk</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Student</span> <span class="kd">extends</span> <span class="nx">Person</span><span class="p">,</span> <span class="nx">Action</span> <span class="p">{</span>
  <span class="nl">number</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">xiaoMing</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">Student</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="nx">xiaoMing</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">xiaoMing</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">xiaoMing</span><span class="p">.</span><span class="kr">number</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">2016222</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">xiaoMing</span><span class="p">.</span><span class="nx">walk</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="接口继承类">接口继承类</h3>

<ul>
  <li>继承类的成员但不包括其实现（只声明，不提供具体实现）</li>
  <li>该接口类型只能被这个类或其子类所实现（implements)</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Control</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">state</span><span class="p">:</span> <span class="kr">any</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 接口继承类</span>
<span class="kr">interface</span> <span class="nx">SelectableControl</span> <span class="kd">extends</span> <span class="nx">Control</span> <span class="p">{</span>
  <span class="nx">select</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 该接口类型只能被这个类或者子类实现</span>
<span class="kd">class</span> <span class="nx">Button</span> <span class="kd">extends</span> <span class="nx">Control</span> <span class="k">implements</span> <span class="nx">SelectbleControl</span> <span class="p">{</span>
  <span class="nx">select</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">TextBox</span> <span class="kd">extends</span> <span class="nx">Control</span> <span class="p">{</span>
  <span class="nx">select</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// error! Image类不是Control类或其子类，缺少state属性</span>
<span class="kd">class</span> <span class="nx">Image</span> <span class="k">implements</span> <span class="nx">SelectableControl</span> <span class="p">{</span>
  <span class="nx">select</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Location</span> <span class="p">{</span>
  
<span class="p">}</span>
</code></pre></div></div>

<h2 id="函数">函数</h2>

<h3 id="函数类型">函数类型</h3>

<blockquote>
  <p>函数类型包含了参数类型和返回值类型</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">func</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">number</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span> <span class="p">};</span>
<span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="可选参数和默认参数">可选参数和默认参数</h3>

<ul>
  <li>可选参数在参数名旁用“？”表示可选</li>
  <li>可选参数必须跟在必须参数后面</li>
  <li>默认参数表示传入参数为undefined时使用默认值</li>
  <li>使用扩展运算符收集剩余的多个参数</li>
</ul>

<h3 id="重载">重载</h3>

<ul>
  <li>如果想定义的函数参数和返回值可能出现多种情况，为函数提供多个函数类型定义来进行函数重载</li>
  <li>编译器会从函数定义列表第一个开始尝试定义，所以第一个一定要是最精确的定义</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">suits</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">hearts</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">spades</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">clubs</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">diamonds</span><span class="dl">"</span><span class="p">];</span>
<span class="kd">function</span> <span class="nx">pickCard</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="p">{</span> <span class="nl">suit</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span> <span class="nl">card</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="p">}[]):</span><span class="kr">number</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">pickCard</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="p">{</span> <span class="nl">suit</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span> <span class="nl">card</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="p">};</span>
<span class="kd">function</span> <span class="nx">pickCard</span><span class="p">(</span><span class="nx">x</span><span class="p">):</span> <span class="kr">any</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">pickedCard</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">pickedCard</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">pickedSuit</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">x</span> <span class="o">/</span> <span class="mi">13</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">suit</span><span class="p">:</span> <span class="nx">suits</span><span class="p">[</span><span class="nx">pickedSuit</span><span class="p">],</span> <span class="na">card</span><span class="p">:</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">13</span> <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="字面量类型">字面量类型</h2>

<ul>
  <li>字面量类型是指一个抽象类型中更具体固定的子类型（值），比如“string”类型中的“hello world”它是一个具体值也是一个固定类型，“hello tom”不等于“hello world”，也就意味着“hello tom”不是“hello world”字面量类型。</li>
  <li>目前ts中有三种可用的字面量类型集合：字符串字面量类型集合、数字字面量类型集合、布尔字面量类型集合</li>
  <li>字面量类型通过type关键字或直接拿一个集合放在类型位置上定义。</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Easing</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">ease-in</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">ease-out</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">ease-in-out</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">Size</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">|</span> <span class="mi">16</span> <span class="o">|</span> <span class="mi">32</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">Disabled</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="kr">interface</span> <span class="nx">MapConfig</span> <span class="p">{</span>
  <span class="nl">lng</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">lat</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">tileSize</span><span class="p">:</span> <span class="mi">8</span> <span class="o">|</span> <span class="mi">16</span> <span class="o">|</span> <span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="联合类型和交叉类型unions-and-intersection-types">联合类型和交叉类型（Unions and Intersection Types）</h2>

<h2 id="类">类</h2>

<ul>
  <li>基于类的面向对象编程方式</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Greeter</span> <span class="p">{</span>
  <span class="c1">// 属性</span>
  <span class="nl">greeting</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="c1">// 构造函数</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">greeting</span> <span class="o">=</span> <span class="nx">message</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 方法</span>
  <span class="nx">greet</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// this表示访问类的成员</span>
    <span class="k">return</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">greeting</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 构造实例</span>
<span class="kd">let</span> <span class="nx">greeter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Greeter</span><span class="p">(</span><span class="dl">"</span><span class="s2">world</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="继承">继承</h3>

<ul>
  <li>使用继承扩展现有的类</li>
</ul>

<blockquote>
  <p>例1:</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 基类（超类）</span>
<span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nx">move</span><span class="p">(</span><span class="nx">distanceInMeters</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Animal moved </span><span class="dl">"</span><span class="p">,</span> <span class="nx">distanceInMeters</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 继承animal类  派生类（子类）</span>
<span class="kd">class</span> <span class="nx">Dog</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nx">bark</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">woof!</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dog</span><span class="p">();</span>
<span class="nx">dog</span><span class="p">.</span><span class="nx">bark</span><span class="p">();</span>
<span class="nx">dog</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>例2:</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">theName</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">theName</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">move</span><span class="p">(</span><span class="nx">distanceInMeters</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">move</span><span class="dl">"</span><span class="p">,</span> <span class="nx">distanceInMeters</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Snake</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 以name入参，执行基类的构造方法(必须的)</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span> 
  <span class="c1">// 重写基类的move方法</span>
  <span class="nx">move</span><span class="p">(</span><span class="nx">distanceInMeters</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Slithering</span><span class="dl">"</span><span class="p">);</span>
    <span class="c1">// 执行基类的move方法（基类：当作函数时会执行构造函数；当作对象时可获取属性和方法）</span>
    <span class="k">super</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="nx">distanceInMeters</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Horse</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">move</span><span class="p">(</span><span class="nx">distanceInMeters</span> <span class="o">=</span> <span class="mi">45</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Galloping</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">super</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="nx">distanceInMeters</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h3 id="类成员修饰符">类成员修饰符</h3>

<ul>
  <li>这些修饰符修饰的成员都是当类被实例化时才会被初始化的属性，反过来讲是依附于实例存在的属性（区别于静态属性）</li>
</ul>

<table>
  <thead>
    <tr>
      <th>修饰符</th>
      <th>含义</th>
      <th>兼容比较</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>public（默认）</td>
      <td>可被自由访问</td>
      <td>不同声明处，但类型相同则兼容</td>
    </tr>
    <tr>
      <td>private</td>
      <td>可以在声明它的类外部访问</td>
      <td>相同声明处，且类型相同则兼容</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>可以在声明它的类和派生类中访问</td>
      <td>相同声明处，且类型相同则兼容</td>
    </tr>
    <tr>
      <td>readonly</td>
      <td>只读属性，表示必须在声明时或构造函数里被初始化</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>例1: 默认修饰符public</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="k">public</span> <span class="kd">constructor</span><span class="p">(</span><span class="nx">theName</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">theName</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">public</span> <span class="nx">move</span><span class="p">(</span><span class="nx">distanceInMeters</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">move</span><span class="dl">"</span><span class="p">,</span> <span class="nx">distanceInMeters</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>例2: private修饰的属性不可在其类外访问</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="c1">// 类的私有属性相当于只局限于该类内部自己使用的属性</span>
  <span class="k">private</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">theName</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">theName</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// err!私有属性不可在声明它的类外使用</span>
<span class="k">new</span> <span class="nx">Animal</span><span class="p">(</span><span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">).</span><span class="nx">name</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>例3: 不同声明，相同类型的private修饰类型不兼容</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">theName</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">theName</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Rhino</span> <span class="kd">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="dl">"</span><span class="s2">Rhino</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Employee</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">theName</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">theName</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">(</span><span class="dl">"</span><span class="s2">Goat</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">rhino</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rhino</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">(</span><span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">);</span>

<span class="c1">// 继承了基类的子类和基类兼容</span>
<span class="nx">animal</span> <span class="o">=</span> <span class="nx">rhino</span><span class="p">;</span>
<span class="c1">// 结构相同但属性不是同一处声明的不兼容</span>
<span class="nx">animal</span> <span class="o">=</span> <span class="nx">employee</span><span class="p">;</span> <span class="c1">// err! Animal 与Employee不兼容</span>
</code></pre></div></div>

<blockquote>
  <p>例4: protected成员与private类似，但是多了仍可以在派生类中访问到的性质</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="c1">// 基类中声明的保护类型</span>
  <span class="k">protected</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Employee</span> <span class="kd">extends</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">department</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">department</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">department</span> <span class="o">=</span> <span class="nx">department</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">public</span> <span class="nx">getElevatorPitch</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 派生类中仍可以访问到基类中的保护类型成员</span>
    <span class="k">return</span> <span class="s2">`Hello, my name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">. I work in </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">department</span><span class="p">}</span><span class="s2">.`</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">howard</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">(</span><span class="dl">"</span><span class="s2">Howard</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Sales</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">howard</span><span class="p">.</span><span class="nx">getElevatorPitch</span><span class="p">());</span>
<span class="c1">// err! 不可在基类和派生类外访问到保护成员</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">howard</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>例5: 构造函数被标记为protected，意味着该类不可被实例化，但可被继承（不可在类外访问执行，但可在派生类中访问执行）</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="k">protected</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="k">protected</span> <span class="kd">constructor</span><span class="p">(</span><span class="nx">theName</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">theName</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Employee</span> <span class="kd">extends</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">department</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">department</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 可在派生类中调用基类中保护类型的构造函数</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">department</span> <span class="o">=</span> <span class="nx">department</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nx">getElevatorPitch</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">department</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">howard</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">(</span><span class="dl">"</span><span class="s2">Howard</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Sales</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// err!不可在类外执行保护类型的构造函数</span>
<span class="kd">let</span> <span class="nx">john</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">"</span><span class="s2">John</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>例6: 只读属性只能在声明时或构造函数里被初始化</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Octopus</span> <span class="p">{</span>
  <span class="k">readonly</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="c1">// 声明时初始化</span>
  <span class="k">readonly</span> <span class="nx">numberOfLegs</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="kd">constructor</span> <span class="p">(</span><span class="nx">theName</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 构造函数里初始化</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">theName</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">tom</span> <span class="o">=</span> <span class="nx">nem</span> <span class="nx">Octopus</span><span class="p">(</span><span class="dl">'</span><span class="s1">Tom</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// err! 只读属性</span>
<span class="nx">tom</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Tim</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="参数属性">参数属性</h3>

<blockquote>
  <p>给构造函数的参数增加成员修饰符实现直接对成员的声明&amp;初始化</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Octopus</span> <span class="p">{</span>
  <span class="k">readonly</span> <span class="nx">numberOfLegs</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="k">readonly</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>

  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="存取器">存取器</h3>

<ul>
  <li>getters/setters：截取对对象成员的访问和赋值</li>
  <li>只有get无set的存取器被自动推断为readonly</li>
</ul>

<blockquote>
  <p>给普通类加上存取器的使用，使得获取和赋值操作必须经过中间动作</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ---普通类</span>
<span class="kd">class</span> <span class="nx">Employee</span> <span class="p">{</span>
  <span class="nl">salary</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">tom</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">();</span>
<span class="c1">// 普通类成员可以被随意访问修改</span>
<span class="nx">tom</span><span class="p">.</span><span class="nx">salary</span> <span class="o">=</span> <span class="mi">2500</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tom</span><span class="p">.</span><span class="nx">salary</span><span class="p">);</span>

<span class="c1">// ---加入存取器</span>
<span class="kd">let</span> <span class="nx">password</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">123</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">class</span> <span class="nx">Employee</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">_salary</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="kd">get</span> <span class="nx">salary</span><span class="p">():</span> <span class="kr">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_salary</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">元</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">set</span> <span class="nx">salary</span><span class="p">(</span><span class="nx">newSalary</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">password</span> <span class="o">&amp;&amp;</span> <span class="nx">password</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">123</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_salary</span> <span class="o">=</span> <span class="nx">newSalary</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">err</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Employee</span><span class="p">();</span>
<span class="nx">employee</span><span class="p">.</span><span class="nx">salary</span> <span class="o">=</span> <span class="mi">2500</span><span class="p">;</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">employee</span><span class="p">.</span><span class="nx">salary</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="静态属性">静态属性</h3>

<blockquote>
  <p>静态属性只存在于类本身身上，而不是类的实例上，访问时直接以访问类对象的属性的形式访问</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="k">static</span> <span class="nx">eyes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">static</span> <span class="nx">legs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">getPersonFeature</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">eyes</span> <span class="o">+</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">legs</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">tom</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">Tom</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">tom</span><span class="p">.</span><span class="nx">getPersonFeature</span><span class="p">());</span>
</code></pre></div></div>

<h3 id="抽象类">抽象类</h3>

<ul>
  <li>抽象类作为其他派生类的基类使用，一般不会被直接实例化（类的基础模板类）</li>
  <li>不同于接口，抽象类内部可以包含非抽象成员的实现细节</li>
  <li>通过abstract定义抽象类和抽象方法</li>
  <li>抽象方法不包含具体实现，必须在派生类中实现</li>
</ul>

<blockquote>
  <p>抽象类举例</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kd">abstract</span> <span class="nx">makeSound</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">move</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">move</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="泛型generics">泛型（Generics）</h2>

<ul>
  <li>为了支持组件重用：一个组件支持多种类型的数据</li>
</ul>

<h3 id="泛型变量">泛型变量</h3>

<ul>
  <li>泛型变量用来指代数据的类型。它是一种特殊的变量，指类型而不是指值;用 &lt;&gt; 表示，在做定义时候使用</li>
</ul>

<blockquote>
  <p>定义一个泛型函数</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// &lt;T&gt; 声明了一个泛型变量T，然后在后面的类型表示中就可以使用它了</span>
<span class="kd">function</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 可当作类型描述中的一部分使用</span>
<span class="kd">function</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]):</span> <span class="nx">T</span><span class="p">[]</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>定义一个泛型接口</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">GenericIdentityFn</span> <span class="p">{</span>
  <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 接口内共享同一个泛型变量</span>
<span class="kr">interface</span> <span class="nx">GenericIdentityFn</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">(</span><span class="na">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span><span class="p">;</span>
  <span class="nl">myArr</span><span class="p">:</span> <span class="nx">T</span><span class="p">[];</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>定义一个泛型类</p>
</blockquote>

<ul>
  <li>泛型类指的是实例部分的类型，所以静态属性不能用泛型。</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">GenericNumber</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">zeroValue</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="nl">add</span><span class="p">:</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">emtity</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GenericNumber</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="泛型约束">泛型约束</h3>

<ul>
  <li>泛型作为类型的指代，故也可以理解泛型和接口可以组合使用，用来表示具有某些特定属性的泛型（泛型约束）</li>
</ul>

<blockquote>
  <p>下例展示了限制只可接受带有length属性的数据（允许带有length属性的数据类型）</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Lengthwise</span> <span class="p">{</span>
  <span class="nl">length</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">loggingIdentity</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Lengthwise</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arg</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">arg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="枚举">枚举</h2>

<ul>
  <li>使用枚举可以定义一组带名字的常量</li>
  <li>ts支持数字和基于字符串的枚举</li>
  <li>使用enum进行定义</li>
</ul>

<h3 id="数字枚举">数字枚举</h3>

<blockquote>
  <p>数字枚举具有自增长的性质, 会依据上一个成员的值自增得到下一个成员的值（默认第一个是0）</p>
</blockquote>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Direction</span> <span class="p">{</span>
  <span class="nx">Up</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="nx">Down</span><span class="p">,</span> <span class="c1">// 2</span>
  <span class="nx">Left</span><span class="p">,</span> <span class="c1">// 3</span>
  <span class="nx">Right</span> <span class="c1">// 4</span>
<span class="p">}</span>

<span class="kr">enum</span> <span class="nx">Direction</span> <span class="p">{</span>
  <span class="nx">Up</span><span class="p">,</span> <span class="c1">// 0</span>
  <span class="nx">Down</span><span class="p">,</span> <span class="c1">// 1</span>
  <span class="nx">Left</span><span class="p">,</span> <span class="c1">// 2</span>
  <span class="nx">Right</span><span class="p">,</span> <span class="c1">// 3</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">act</span><span class="p">(</span><span class="nx">move</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">direction</span><span class="p">:</span> <span class="nx">Direction</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">move</span><span class="p">,</span> <span class="nx">direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">act</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nx">Direction</span><span class="p">.</span><span class="nx">Up</span><span class="p">);</span>

<span class="c1">// 无初始化的成员要么在首位，要么在明确被数值初始化了的成员之后</span>
<span class="kr">enum</span> <span class="nx">E</span> <span class="p">{</span>
  <span class="nx">A</span> <span class="o">=</span> <span class="nx">getSomeValue</span><span class="p">(),</span>
  <span class="nx">B</span><span class="p">,</span> <span class="c1">// Error!</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="字符串枚举">字符串枚举</h3>

<h2 id="变量声明">变量声明</h2>

<ul>
  <li>let和const是es6规范中新增的变量声明语法，因为ts是js的超集，所以其本身就支持二者，并且推荐在ts中使用。</li>
</ul>

<h3 id="varletconst">var,let,const</h3>

<ul>
  <li>下面简要介绍一下三种变量声明的特点。</li>
</ul>

<table>
  <thead>
    <tr>
      <th>关键字</th>
      <th>作用域</th>
      <th>说明</th>
      <th>声明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>var</td>
      <td>var作用域/函数作用域</td>
      <td>在包含它的函数，模块，命名空间或全局作用域内任何文职被访问到</td>
      <td>可重复声明覆盖</td>
    </tr>
    <tr>
      <td>let</td>
      <td>词法作用域/块作用域</td>
      <td>变量在包含它们的块或for循环之外不能访问</td>
      <td>不能在声明之前读写，不可多次声明</td>
    </tr>
    <tr>
      <td>const</td>
      <td>词法作用域/块作用域</td>
      <td>变量在包含它们的块或for循环之外不能访问</td>
      <td>不能在声明之前读写，不可多次声明，不可重复赋值</td>
    </tr>
  </tbody>
</table>

<h3 id="解构">解构</h3>

<ul>
  <li>
    <p>解构数组</p>

    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">second</span><span class="p">,</span> <span class="nx">first</span><span class="p">];</span>
<span class="kd">function</span> <span class="nx">fun</span><span class="p">([</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">]:</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">])</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">first</span><span class="p">,</span> <span class="nx">second</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">fun</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr2</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">[,</span> <span class="nx">b</span><span class="p">,</span> <span class="p">,</span> <span class="nx">d</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr2</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>解构对象</p>

    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="na">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">{</span> <span class="nx">first</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="nx">aaa</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="nx">bbb</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="kd">let</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="nx">val1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="nx">val2</span> <span class="p">}:</span> <span class="p">{</span> <span class="nl">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">fun</span><span class="p">(</span><span class="nx">obj</span><span class="p">:</span> <span class="p">{</span><span class="nl">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">?:</span> <span class="kr">number</span><span class="p">})</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>函数声明</p>

    <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">C</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">b</span><span class="p">?:</span> <span class="kr">number</span> <span class="p">};</span>
<span class="kd">function</span> <span class="nx">fun</span><span class="p">({</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}:</span> <span class="nx">C</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">};</span>
<span class="c1">// 为参数对象属性设置默认值（无该属性时生效）</span>
<span class="kd">function</span> <span class="nx">fun2</span><span class="p">({</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">""</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}:</span> <span class="nx">C</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">};</span>
<span class="c1">// 为参数对象设置默认对象（无该对象时生效）</span>
<span class="kd">function</span> <span class="nx">fun3</span><span class="p">({</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="dl">""</span> <span class="p">}:</span> <span class="nx">C</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>展开</p>
    <ol>
      <li>对象，数组等（可迭代对象）可展开</li>
      <li>展开会覆盖前面的同名属性</li>
      <li>仅包含对象自身的可枚举属性（会丢失方法）</li>
      <li>ts中不允许展开泛型函数上的类型参数</li>
    </ol>
  </li>
</ul>

<h2 id="类型推论">类型推论</h2>

<h2 id="类型兼容性">类型兼容性</h2>

<h2 id="高级类型">高级类型</h2>

<h2 id="symbols">Symbols</h2>

<h2 id="迭代器和生成器">迭代器和生成器</h2>

<h2 id="模块">模块</h2>

<h2 id="命名空间">命名空间</h2>
:ET