---
layout: post
title:  typescript要点记录
date:   2021-02-01
categories: notes
tags: typescript
---

* content
{:toc}


> 参考资料：<https://www.tslang.cn/docs/handbook/basic-types.html>


## 基础类型

### ts中支持的基础数据类型

- boolean：布尔值
- number：数字
- string：字符串
- [] / number[] / Array\<number>：数组
- [string, number]：元组（表示一个已知元素数量和类型的数组，各元素类型不必相同）
- enum：枚举（为一组数值赋予友好的名字）
- any：不进行类型检查的任意类型
- void：没有任何类型（通常表示无返回值）
- null
- undefined
- never：永远不存在值的类型（总会抛出异常/无返回值的函数/箭头函数返回值/函数存在无法到达的终点）
- object

### 类型断言

- 表示人为确定某值应该当作什么类型去处理
- 有两种写法：

  ```ts
  let val = "a string";
  // 尖括号语法
  let valLen1: number = (<string>val).length;
  // as 语法
  let valLen2: number = (val as string).length;
  ```

## 变量声明

- let和const是es6规范中新增的变量声明语法，因为ts是js的超集，所以其本身就支持二者，并且推荐在ts中使用。

### var,let,const

- 下面简要介绍一下三种变量声明的特点。

关键字 | 作用域 | 说明 | 声明
------|-------|-----|-----
var | var作用域/函数作用域 | 在包含它的函数，模块，命名空间或全局作用域内任何文职被访问到 | 可重复声明覆盖
let | 词法作用域/块作用域 | 变量在包含它们的块或for循环之外不能访问 | 不能在声明之前读写，不可多次声明
const | 词法作用域/块作用域 | 变量在包含它们的块或for循环之外不能访问 | 不能在声明之前读写，不可多次声明，不可重复赋值

### 解构

- 解构数组

  ```ts
  let arr = [1, 3];
  let [first, second] = arr;
  let [first, second] = [second, first];
  function fun([first, second]: [number, number]) {
    console.log(first, second);
  }
  fun(arr);
  let arr2 = [1, 2, 3, 4];
  let [a, ...rest] = arr2;
  let [, b, , d] = arr2;
  ```

- 解构对象

  ```ts
  let obj = {
    a: 1,
    b: 2,
    c: 3,
  };
  let { a, b } = obj;
  let { first, ...rest } = obj;
  let { a: aaa, b: bbb } = obj;
  let { a: val1, b: val2 }: { a: number, b: number } = obj;
  function fun(obj: {a: number, b?: number}) {
    let { a, b = 2 } = obj;
    return a + b;
  }
  ```

- 函数声明

  ```ts
  type C = { a: string, b?: number };
  function fun({ a, b }: C): void {
    console.log(a, b);
  };
  // 为参数对象属性设置默认值（无该属性时生效）
  function fun2({ a = "", b = 0 }: C): void {
    console.log(a, b);
  };
  // 为参数对象设置默认对象（无该对象时生效）
  function fun3({ a, b = 0 } = { a: "" }: C): void {
    console.log(a, b);
  };
  ```

- 展开
  1. 对象，数组等（可迭代对象）可展开
  2. 展开会覆盖前面的同名属性
  3. 仅包含对象自身的可枚举属性（会丢失方法）
  4. ts中不允许展开泛型函数上的类型参数

## 接口

- 接口作用：
  1. 为类型命名
  2. 为代码定义契约

```ts
interface LabelledValue {
  label: string;
}

function printLabel(labelObj: LabelledValue) {
  console.log(labelObj.label);
}

// it‘s ok
printLabel({
  label: "hello",
});

// error TS2345（对象字面量会经过额外属性检查，若存在目标类型不包含的属性时就会报错）
printLabel({
  label: "hello",
  name: "world"
});

let obj = {
  label: "hello",
  name: "world"
}
// 变量引用可绕过额外属性检查
printLabel(obj);

// 使用类型断言可以绕过额外属性检查
printLabel({ label: "hello", name: "world" } as LabelledValue);


// 使用字符串索引签名在接口中定义一个属性，表示该类型对象会带有任意数量的其他属性
interface Student {
  name: string;
  [propName: string]: any;
}
```

### 对象类型

- 可选属性：接口中定义可选的属性字段（对可能存在对属性进行预定义，引用不存在属性时将抛出错误）
  
  ```ts
  interface Person {
    name: string;
    age?: number;
  }
  ```

- 只读属性：接口中定义只能在对象刚刚创建时修改其值的属性

  ```ts
  interface Person {
    readonly name: string;
  }
  ```

### 函数类型

- 接口也可描述函数类型（包括参数类型和返回值类型）

```ts
interface QueryPerson {
  (name: string, age: number): boolean;
}
let ifPersonExist: QueryPerson;
// 参数名可以不一样，参数和返回值类型可以不写 ts会依据接口进行类型推断
ifPersonExist = function(name: string, age: number): boolean {
  return true;
}
```

### 可索引类型

- 可索引类型具有一个索引签名，它描述对象索引(key)的类型，还有相应的索引返回值(value)的类型
- ts支持两种索引类型：number，string
- 同时使用两种索引类型时，二者的value类型需保持相同（因为都是转为string类型索引的）
- 可以在接口中设置readonly，防止给索引赋值

```ts
interface StringArr {
  // 表示key为number类型，value为string类型，并且不可修改
  readonly [index: number]: string;
}

let myArr: StringArr;
myArr = ["bob", "fred"];

let firstStr: string = myArr[0];
```

### 类类型

- 