---
layout: post
title:  typescript要点记录
date:   2021-02-01
categories: notes
tags: typescript
---

* content
{:toc}


> 参考资料：<https://www.tslang.cn/docs/handbook/basic-types.html>


## 基础类型

### ts中支持的基础数据类型

- boolean：布尔值
- number：数字
- string：字符串
- [] / number[] / Array\<number>：数组
- [string, number]：元组（表示一个已知元素数量和类型的数组，各元素类型不必相同）
- enum：枚举（为一组数值赋予友好的名字）
- any：不进行类型检查的任意类型
- void：没有任何类型（通常表示无返回值）
- null
- undefined
- never：永远不存在值的类型（总会抛出异常/无返回值的函数/箭头函数返回值/函数存在无法到达的终点）
- object

### 类型断言

- 表示人为确定某值应该当作什么类型去处理
- 有两种写法：

  ```ts
  let val = "a string";
  <!-- 尖括号语法 -->
  let valLen1: number = (<string>val).length;
  <!-- as 语法 -->
  let valLen2: number = (val as string).length;
  ```

## 变量声明

- let和const是es6规范中新增的变量声明语法，因为ts是js的超集，所以其本身就支持二者，并且推荐在ts中使用。

### var,let,const

- 下面简要介绍一下三种变量声明的特点。

关键字 | 作用域 | 说明 | 声明
------|-------|-----|-----
var | var作用域/函数作用域 | 在包含它的函数，模块，命名空间或全局作用域内任何文职被访问到 | 可重复声明覆盖
let | 词法作用域/块作用域 | 变量在包含它们的块或for循环之外不能访问 | 不能在声明之前读写，不可多次声明
const | 词法作用域/块作用域 | 变量在包含它们的块或for循环之外不能访问 | 不能在声明之前读写，不可多次声明，不可重复赋值

### 解构

- 解构数组

  ```ts
  let arr = [1, 3];
  let [first, second] = arr;
  let [first, second] = [second, first];
  function fun([first, second]: [number, number]) {
    console.log(first, second);
  }
  fun(arr);
  let arr2 = [1, 2, 3, 4];
  let [a, ...rest] = arr2;
  let [, b, , d] = arr2;
  ```

- 解构对象

  ```ts
  let obj = {
    a: 1,
    b: 2,
    c: 3,
  };
  let { a, b } = obj;
  let { first, ...rest } = obj;
  let { a: aaa, b: bbb } = obj;
  let { a: val1, b: val2 }: { a: number, b: number } = obj;
  function fun(obj: {a: number, b?: number}) {
    let { a, b = 2 } = obj;
    return a + b;
  }
  ```

- 函数声明

  ```ts
  type C = { a: string, b?: number };
  function fun({ a, b }: C): void {
    console.log(a, b);
  };
  <!-- 为参数对象属性设置默认值（无该属性时生效） -->
  function fun2({ a = "", b = 0 }: C): void {
    console.log(a, b);
  };
  <!-- 为参数对象设置默认对象（无该对象时生效） -->
  function fun3({ a, b = 0 } = { a: "" }: C): void {
    console.log(a, b);
  };
  ```

- 展开
  1. 对象，数组等（可迭代对象）可展开
  2. 展开会覆盖前面的同名属性
  3. 仅包含对象自身的可枚举属性（会丢失方法）
  4. ts中不允许展开泛型函数上的类型参数
